%\documentclass[oribibl]{llncs}
\documentclass{easychair}
%\usepackage{pslatex}

\usepackage{times}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{mathpartir} % ./
\usepackage{color}
\usepackage{xspace} 
%\usepackage[pdftex]{graphicx}
%\usepackage[small]{caption}
\usepackage{fancybox}
\usepackage{url}
\usepackage{multirow}
\usepackage{comment}
\usepackage{listing}
\usepackage{colortbl}
\usepackage{subfigure}

%\usepackage{times}
\usepackage{framed}
\usepackage{lineno}

\input{macros}
\renewcommand{\shadowsize}{1pt}

\begin{document}

\title{Conflicts, Models and Heuristics for Quantifier Instantiation in SMT}

\author {Andrew Reynolds\inst{1}}

\institute{
Department of Computer Science, The University of Iowa, USA
}
\maketitle

\pagestyle{plain}
%\pagestyle{empty}

\begin{abstract}
Satisfiability Modulo Theories (SMT) solvers have
emerged as prominent tools in formal methods applications.
While originally targeted towards quantifier-free inputs,
SMT solvers are now often used for handling quantified formulas in automated
theorem proving and software verification applications.
The most common technique for handling quantified formulas in modern SMT solvers
in quantifier instantiation.
This paper gives an overview of recent advances in quantifier instantiation in SMT.
In addition to the well-known technique known as E-matching,
we discuss the use of conflicts and models for 
accelerating the search for (un)satisfiably.
We further mention new instantiation-based techniques
that are specialized to background theories such as linear real and integer arithmetic,
and future work in this direction.
\end{abstract}

\section{Introduction}

The use of quantified formulas is highly important in a number of applications.
In automated theorem proving applications~\cite{blanchette2013extending,bobot2011why3},
quantified formulas often correspond to a set of background axioms,
or to encode theories not natively supported by solvers.
Quantified formulas also are used in software verification applications~\cite{DBLP:conf/icse/Leino04,DBLP:conf/itp/ChapmanS14},
where they may be used for explicit function unfolding, or to reason about code by contracts.
In synthesis, conjectures that specify universal properties for functions to synthesize are often expressed as formulas
with one quantifier alternation.
Finally, in planning applications, quantified formulas are sometimes used to specified
that a desired plan must have certain properties for all relevant time points.

Unfortunately, the satisfiability problem for quantified formulas is highly challenging 
and only decidable in limited cases.
For example,
the satisfiability problem for the Bernays-Shonfinkel class of formulas
having quantifier prenex $\exists^\ast \forall^\ast$ and no function symbols
is NEXPTIME-complete;
quantifier elimination algorithms can be used for deciding 
formulas e.g. in pure linear real arithmetic in time that is worst-case doubly exponential in the number of quantifier blocks.
%Even worse, the general case of quantified formulas having uninterpreted function symbols is undecidable.
In spite of the theoretical challenges, many quantified formulas that arise in practice
can be handled efficiently due to the development of efficient algorithms used by modern automated theorem provers.

A growing number of modern tools exist for reasoning about first-order quantified formulas.
A number of automated theorem provers
such as Vampire~\cite{DBLP:conf/cav/KovacsV13}, E~\cite{schulz2002brainiac}, and SPASS~\cite{weidenbach2009spass}
were developed to target quantified formulas in single-sorted first-order logic.
More recently, these tools have been extended with dedicated support for background theories~\cite{DBLP:conf/frocos/AlthausKW09,DBLP:conf/cade/BaumgartnerBW15}.
For the most part, tools from this community are superposition-based,
although some are instantiation-based such as the Inst-Gen calculus used by iProver~\cite{ganzinger2003new}.
A recent approach known as AVATAR~\cite{DBLP:conf/cade/RegerSV15} leverages support in SAT and SMT solvers for quantifier-free formulas
in combination with a superposition-based theorem prover.

In contrast to these tools, Satisfiability Modulo Theories (SMT) solvers such as CVC~\cite{stump2002cvc}, Yices~\cite{dutertre2006yices}, and Z3~\cite{Z3}, 
were originally developed to target quantifier-free formulas in background theories,
but have more recently been extended with support for universally quantified formulas.
The approaches here are mostly instantiation-based based~\cite{Detlefs03simplify:a,MouraBjoerner07,GeBarrettTinelli07},
although some approaches are based on superposition~\cite{de2008engineering}.

This paper overviews recent techniques for quantifier instantiation in SMT solvers.
In Section~\ref{sec:quant}, we outline an abstract procedure used by most SMT solvers that support quantified formulas.
We then focus on three general-purpose instantiation strategies for handling quantified formulas in SMT:
\begin{itemize}
\item Section~\ref{sec:ematching} will discuss \emph{heuristic} techniques for quantifier instantiation based on pattern-matching that
are widely-used by current solvers,
\item Section~\ref{sec:cbqi} will discuss how finding \emph{conflicts} can improve the ability of solvers to answer ``unsat",
\item Section~\ref{sec:mbqi} will examine how constructing candidate \emph{models} can enable the solvers to answer ``sat".
\end{itemize} 
Section~\ref{sec:cegqi} introduces further techniques for quantifier instantiation in SMT that 
are specialized to theories.
Finally, we conclude in Section~\ref{sec:conclusion} with a summary and mention possible future work.

\section{Support for Quantified Formulas in an SMT Solver}
\label{sec:quant}

Most modern SMT solvers are based on the DPLL($T$) solving architecture,
where a set of decision procedures for the background theory are modularly combined with a SAT solver for propositional satisfiability~\cite{nieuwenhuis2006solving}.
\begin{comment}
Given a set of formulas $\Gamma$ as input to a DPLL($T$)-based SMT solver, its underlying SAT solver
abstracts each literal in $\Gamma$ as unique Boolean variable.
The SAT solver clausifies $\Gamma$ and returns that 
either it is propositionally unsatisfiable (in which case it is also unsatisfiable modulo $T$),
or returns a set of literals $M$ that propositionally entail it.
We write $M \models_p \Gamma$ to denote this case, and refer to $M$ as a satisfying assignment for $\Gamma$.
It then uses a decision procedure to
check the $T$-satisfiability of $M$, that is, its satisfiability modulo the background theory $T$.
If $M$ is satisfiable, then we may conclude that $\Gamma$ is satisfiable modulo $T$.
Otherwise, it returns a subset $C$ of $M$ that is unsatisfiable modulo the background theory and adds the clause $\neg C$ to $\Gamma$,
which is often referred to as a conflict clause.
\end{comment}
These solvers have also been extended 
in the past decade with approaches for universal and existential quantification~\cite{Detlefs03simplify:a,MouraBjoerner07,GeBarrettTinelli07}.
For consistency, in this paper we assume all existential quantification is rewritten to universal quantification:
\[
\exists \vec x\, P( \vec x ) \transform \neg \forall \vec x\, \neg P( \vec x )
\]
%This section gives an brief review of how DPLL(T)-based solvers check the satisfiability of
%inputs with quantified formulas.
%In a DPLL($T$)-based approach for quantified formulas, 
%each closed universally quantified formula is abstracted as a Boolean variable by the SAT solver as well.

\begin{figure}[t]
\begin{framed}
\begin{internallinenumbers}
$\funcsmtsolve( \Gamma )$:
\begin{enumerate}
\item[\ ] If $\Gamma$ is propositionally unsatisfiable,
\begin{enumerate}
\item[\ ] return ``unsat".
\end{enumerate}
\item[\ ] Otherwise, let $M = E \uplus Q$ be a set of literals such that $M \models_p \Gamma$.
\item[\ ] If $E$ is $T$-unsatisfiable,
\begin{enumerate}
\item[\ ] return $\funcsmtsolve( \Gamma \cup \neg C )$ for some $T$-unsatisfiable $C \subseteq E$.
\end{enumerate}
\item[\ ] Otherwise, let $( r, L ) = \funcqi( E, Q )$.
\item[\ ] If $r$ is ``unknown",
\begin{enumerate}
\item[\ ] return $\funcsmtsolve( \Gamma \cup L )$.
\end{enumerate}
\item[\ ] Otherwise, return ``sat".
\end{enumerate}
$\funcqi( E, Q )$:
\begin{enumerate}
\item[\ ] Do one of the following:
\begin{enumerate}
\item[\ ] Return $( \text{``unknown"}, L )$ for some set $L$ of $T$-lemmas.
\item[\ ] Return $( \text{``sat"}, \emptyset )$, if $E \cup Q$ is $T$-satisfiable.
\end{enumerate}
\end{enumerate}
\end{internallinenumbers}
\end{framed}
\vspace{-2ex}
\caption{An abstract procedure for $T$-inputs $\Gamma_0$ with quantified formulas in an SMT solver.
In Line 5, $E$ is quantifier-free, and the atoms of each literal in $Q$ are universally quantified formulas.
\label{fig:smtq}}
\end{figure}

This section gives an brief review of how DPLL(T)-based solvers check the satisfiability of
inputs with quantified formulas, which can be summarized by the procedure $\funcsmtsolve$ in Figure~\ref{fig:smtq}.
In this procedure, we first check whether this set is propositionally satisfiable using
an underlying satisfiability (SAT) solver in Line 2.
If $\Gamma$ is propositionally unsatisfiable,
then it is also unsatisfiable modulo $T$ and we return ``unsat" in line 3.
Otherwise, in the case that $\Gamma$ is satisfiable, the SAT solver will return a set of literals $M$ that propositionally entails it.
We partition $M$ in line 4 into two parts $E$ and $Q$,
where $E$ is quantifier-free and the atoms of literals in $Q$ are universally quantified formulas.
In line 5, we check the $T$-satisfiability of quantifier-free part $E$ of $M$.
If this is unsatisfiable, then we add the clause $\neg C$ (often referred to as a conflict or blocking clause) to $\Gamma$ in line 6 and repeat,
where $C$ is an unsatisfiable subset of $E$.
If the quantifier-free portion is satisfiable,
we proceed to Line 7, which invokes the abstract procedure $\funcqi$ on $E$ and $Q$.
This procedure either will determine that $E \cup Q$ is $T$-satisfiable and return the pair $( \text{``sat"}, \emptyset )$,
or otherwise will return ( ``unknown", $L$ ), where $L$ is a set of formulas that are valid in theory $T$ (often referred to as $T$-lemmas),
after which the procedure $\funcsmtsolve$ either terminates with ``sat" or adds the set $L$ to $\Gamma$ and repeats.
\begin{example}
Consider the set of $\uflia$-formulas $\Gamma$:
\[
\{ \neg P(a) \vee f(a)>a+1, P( a ) \vee \forall x\, R( x ) \vee (\forall y\, P(y) \vee f( y ) < y) \}
\]
On line 2, a SAT solver consider the propositional abstraction of this set:
\[
\{ \neg A_1 \vee A_2, A_1 \vee A_3 \vee A_4 \}
\]
where for instance $\forall y\, P(y) \vee f( y ) < y$ is abstracted as Boolean variable $A_4$.
We have that e.g. $\{ \neg A_1, A_3 \}$ propositionally entails this set.
Subsequently, line 4 considers the original atoms these variables correspond to, that is,
$M = E \uplus Q = \{ \neg P( a ) \} \uplus \{ \forall x\, R( x ) \}$.
On line 5, we check if $E$ is satisfiable.
Since $E$ is $T$-satisfiable in this case, on line 7
we invoke $\funcqi$ on $(E, Q)$, which will either determine this set is
satisfiable modulo $\uflia$, or add additional formulas to $\Gamma$. 
%DPLL(T) then checks the satisfiability of $\{ \neg P(a), \forall x\, R( x ) \}$ modulo $\uflia$.
\qed
\end{example}

Support for quantified formulas in DPLL($T$)-based SMT solvers depend primarily on how the function $\funcqi$ is implemented.
We will examine such an implementation in this paper, in particular addressing the questions:
\begin{itemize}
\item What lemmas $L$ should we return?
\item How can we establish that $E \cup Q$ is $T$-satisfiable?
\end{itemize}

It is important to note that some SMT approaches to quantified formulas
reason about quantified formulas \emph{eagerly} during the DPLL($T$) search~\cite{MouraBjoerner07}.
In terms of Figure~\ref{fig:smtq}, these approaches invoke $\funcqi$
when $M$ is incomplete and does not necessarily propositionally entail all formulas in $\Gamma$.
The advantage of doing so is that lemmas returned by $\funcqi$ may help prune search space,
while the disadvantage is that calling $\funcqi$ may be expensive and slow the search.
%For simplicity, we assume a lazy approach for handling quantified formulas.

\subsection{Skolemization and Instantiation}
Common implementations of $\funcqi( E, Q )$ in SMT solvers return sets $L$ consisting of $T$-lemmas of the following two forms:
\begin{enumerate}
\item $\neg \forall \vec x\, P( \vec x ) \Rightarrow \neg P( \vec k )$, where $\vec k$ is a set of fresh \emph{Skolem} variables, and
\item $\forall \vec x\, P( \vec x ) \Rightarrow P( \vec t )$, where $\vec t$ is a tuple of ground terms.
\end{enumerate}
Lemmas of the first type, which we refer to as \emph{Skolemization lemmas},
witness the negation of universally quantified formulas for a fresh set of variables $\vec{k}$,
are returned for each quantified formula whose negation occurs in $Q$.
Notice that such lemmas need only be added once per quantified formula.
Lemmas of the second type, which we refer to as \emph{instantiation lemmas},
infer an instance of a universally quantified formula for some tuple of ground terms $\vec{ t }$.
In contrast, multiple lemmas of this form may be added per quantified formula.
Unlike techniques for clause selection in automated theorem provers~\cite{DBLP:conf/cade/SchulzM16},
typical strategies may add instantiation lemmas for \emph{all} quantified formulas in $Q$ simultaneously whenever $\funcqi$ is invoked.
The performance of the solver is highly dependent on a having a good strategy for selecting such instantiation lemmas.
We examine various strategies for selecting instantiation lemmas in Sections~\ref{sec:ematching}-~\ref{sec:cegqi}.

\section{E-matching}
\label{sec:ematching}

The most widely used technique for quantifier instantiation in SMT a heuristic technique known as \emph{E-matching}.
It was originally introduced in the Ph.D. thesis of Greg Nelson~\cite{Nelson:1980:TPV:909447}.
Recently, variants of the approach have been implemented in a number of solvers~\cite{Detlefs03simplify:a,DBLP:conf/cav/BarrettT07,Z3,DBLP:conf/cade/BoutonODF09,CVC4-CAV-11,DBLP:conf/lpar/Rummer12}.
The support for E-matching in these solvers is critical to the success of high-level tools for 
software verification~\cite{DBLP:conf/icse/Leino04,DBLP:conf/itp/ChapmanS14} and automated theorem proving~\cite{blanchette2013extending,bobot2011why3}.
E-matching chooses instances for quantified formulas $\forall \vec x\, \varphi$
based on \emph{pattern terms} whose free variables are $\vec x$.
We will write $p[ \vec x ]$ to denote a term whose free variables are $\vec x$.
%Formally, 
%we say that a ground term $g$ matches $p$ modulo $E$ under substitution $\{ \vec x \mapsto \vec t \}$ if $E \models_T g = p \{ \vec x \mapsto \vec t \}$.
In detail, 
E-matching does the following for each $\forall \vec x\, \varphi[ \vec x ]$ in $Q$:
\begin{enumerate}
\item Choose a set of patterns $p_1[ \vec x ], \ldots, p_m[ \vec x ]$.
\item For each $j = 1, \ldots, m$,
\begin{enumerate}
\item Compute a set of pairs $(\vec t_{1},g_{1}), \ldots, (\vec t_{n}, g_{n})$ 
where for each $i = 1, \ldots, n$, we have that $g_i$ is a ground term from $E$ such that $E \models_T g_{i} = p_j[ \vec t_{i} ]$.
\item Return the lemmas $\{ \forall x\, \varphi[\vec x] \Rightarrow \varphi[\vec t_{1}], \ldots, \forall x\, \varphi[\vec x] \Rightarrow \varphi[\vec t_{n}] \}$.
\end{enumerate}
\end{enumerate}

In other words, we first select a set of pattern terms, which are often some of the subterms of $\varphi$.
For each of these patterns $p_j[ \vec x ]$, we compute a set of pairs of the form $( \vec t_i, g_i )$ where 
$g_i$ is equivalent to $p_j[ \vec t_i ]$ under the assumption that $E$ holds.
We then return instantiation lemmas corresponding to each of these pairs. 
In the context of Figure~\ref{fig:smtq}, these lemmas are included in the return value of $\funcqi$ (set $L$).
Notice in this description, we write $E \models_T g_{i} = p_j[ \vec t_{i} ]$ to denote that $E$ entails
$g_{i} = p_j[ \vec t_{i} ]$ modulo theory $T$.  In typical E-matching implementations, $T$ is limited to the theory of uninterpreted functions and equality.
%We demonstrate this technique in the following examples.

\begin{example}
\label{ex:em2}
Let $E$ be the set $\{ P(a), \neg P(b), R(c), \neg R(a), S(d) \}$ where $a,b,c,d$ are free constants and $P,R,S$ are unary predicates.
Let $\psi$ be $\forall x\, P( x ) \vee R( x )$.
Say we choose the pattern terms $P( x )$ and $R( x )$ for $\psi$.
In Step 2, we compute pairs $( a, P( a ) )$ and $( b, P( b ) )$ for $P( x )$ and
$( a, R( a ) )$ and $( c, R( c ) )$ for $R( x )$,
and E-matching returns $\{
\psi \Rightarrow P( a ) \vee R( a ), \psi \Rightarrow P( b ) \vee R( b ), \psi \Rightarrow P( c ) \vee R( c )
\}$.
\qed
\end{example}

\begin{example}
\label{ex:em2}
E-matching also takes into account equality and uninterpreted functions.
For example, let $E$ be the set $\{ P( a, c ), f( b ) = a \}$,
let $\psi$ be $\forall xy\, P( f( x ), y ) \Rightarrow g( x ) = y$,
and let $P( f( x ), y )$ be a pattern for it.
We may consider the pair $( ( b, c ), P( a, c ) )$, which is such that $E \models_\euf P( a, c ) = P( f( b ), c )$ since $f( b ) = a \in E$,
where $\models_\euf$ denotes entailment the theory of equality and uninterpreted functions.
E-matching in this example returns $\{ \psi \Rightarrow ( P( f( b ), c ) \Rightarrow g( b ) = c \}$.
\qed
\end{example}

Recall in function $\funcqi$, we are interested in the (un)satisfiability of $E \cup Q$.
As mentioned, E-matching selects instantiation lemmas based on pattern matching.
It is typically effective for establishing unsatisfiability.
The intuition for its effectiveness is the following. 
Let $\psi$ be a formula in $Q$ of the form $\forall \vec x\, \varphi[ p[ \vec x ], \vec x ]$, 
that is, $p[ \vec x ]$ is a subterm of $\psi$,
Assume $p[ \vec x ]$ is selected as a pattern for $\psi$, and
that a ground term $g$ from $E$ is such that $E \models_T g = p[ \vec t ]$.
This furthermore implies that $E, \varphi[ p[ \vec t ], \vec t ] \models_T \varphi[ g, \vec t ]$,
that is, by adding an instance of $\psi$ to $E$ we learn that $\varphi[ g, \vec t ]$ holds as well.
%The effect of learning the instantiation $\varphi[ p[ \vec t ], \vec t ]$ 
%suffices to learn $\varphi[ g, \vec t ]$ under the assumption of $E$,
%that is, $E, \varphi[ p[ \vec t ], \vec t ] \models_T \varphi[ g, \vec t ]$.
In other words, 
the goal of E-matching is to, {\bf from $Q$, learn information about ground terms in $E$}.
% i.e. the formula $\varphi[ g, \vec t ]$.
In Example~\ref{ex:em2}, the instantiation lemma returned by E-matching tells us
that the predicate term $P( a, c )$ from $E$ entails $g( b ) = c$, under the assumption that $E$ holds.
This intuition will be revisited in Section~\ref{sec:cbqi}.

\subsection{Pattern Selection}
There is no standard way to determine which patterns to select in E-matching.
The performance of SMT solvers is highly dependent upon having a good method for pattern selection.
In practice, patterns for quantified formulas can be can either be selected manually by the user,
or selected automatically by the SMT solver.
Recent work has explored more sophisticated pattern selection techniques~\cite{DBLP:conf/cav/LeinoP16}.

A typical pattern selection for $\forall \vec x\, \varphi$ includes patterns that are subterms $\varphi$,
and are applications of uninterpreted functions.
For example, if $\varphi$ is $f( x, y ) = x + y$ where $f$ is uninterpreted, then $f( x, y )$ would be selected as a pattern
but not $x + y$.
Moreover, they tend to select multiple eligible patterns when multiple are available, 
e.g. $P( x )$ and $R( x )$ may be selected when $\varphi$ is $P( x ) \vee R( x )$.
Another key choice in pattern selection is whether to consider nested terms, e.g. when $\varphi$ is $P( f( x ) )$,
we may either select $f( x )$ or $P( f( x ) )$, where the latter selection leads to strictly fewer instantiations.
If no eligible term contains all the free variables in $\vec x$, then it selects a pattern consisting of multiple terms.
These are often called \emph{multi-patterns}.
For example, for $R( x, y ) \wedge R( y, z ) \Rightarrow R( x, z )$, then the set $\{ R( x, y ), R( y, z ) \}$ is a multi-pattern.
E-matching adds an instance for this multi-pattern if it could find a substitution for $x, y, z$
that simultaneously matched both of these terms to ground terms in the current context.
Multi-patterns tend to lead to many instantiations, and hence they tend to be chosen with lower priority.
It is yet to be explored how recent techniques for literal selection in automated theorem provers~\cite{DBLP:conf/cade/HoderR0V16}
relate to pattern selection in SMT solvers.

\subsection{Challenge: Too Many Instances}

\begin{figure}[t]
\centering
{
\begin{tabular}{|c|cc|cc|cc|}      
\hline                                                                      
\#Instances & \multicolumn{2}{c|}{{\bf cvc3}} & \multicolumn{2}{c|}{{\bf cvc4}} & \multicolumn{2}{c|}{{\bf z3}} \\
\hline   
1-10 & 1464 & 13.5\% & 1007 & 8.9\% & 1321 & 11.4\% \\
10-100 & 1755 & 16.2\% & 1853 & 16.3\% & 2554 & 22.1\% \\
100-1000 & 3816 & 35.2\% & 3680 & 32.4\% & 4553 & 39.4\% \\
1000-10k & 1893 & 17.4\% & 2468 & 21.7\% & 1779 & 15.4\% \\
10k-100k & 1162 & 10.7\% & 1414 & 12.5\% & 823 & 7.1\% \\
100k-1M & 560 & 5.2\% & 607 & 5.3\% & 376 & 3.3\% \\
1M-10M & 193 & 1.8\% & 330 & 2.9\% & 139 & 1.2\% \\
$>$10M & 10 & 0.1\% & 0 & 0.0\% & 8 & 0.1\%  \\                           
\hline                                                                
\end{tabular}
\\
}
\caption{Number of instantiations by implementations of E-matching in SMT solvers
on unsatisfiable benchmarks they solve with a 300 second timeout from SMT-LIB, TPTP and Isabelle. Data taken from~\cite{ReynoldsTinelliMoura14}.}
\label{fig:results-inst}
\end{figure}

One of the central challenges when using E-matching is dealing with the large number of instantiations it generates.
Figure~\ref{fig:results-inst} gives statistics on the number of instantiations returned by three implementations of E-matching in recent SMT solvers~\cite{DBLP:conf/cav/BarrettT07,CVC4-CAV-11,Z3}
on benchmarks they solve from the the SMT-LIB library~\cite{BarST-SMTLIB}, the TPTP library~\cite{SS98}, 
and the Isabelle proof assistant~\cite{blanchette2013extending}.
For example, cvc4 solves 1853 benchmarks for which it added between 10 and 100 instantiation lemmas.
We can see from this data that the median number of instantiations tends to be between 100 and 1000,
and a majority of benchmarks taking between 10 and 10 thousand instantiations.
A number of benchmarks are solved after upwards of one million instantiations,
and z3 solves one benchmark in the TPTP library after adding more than 19.5 million instantiation lemmas.

The number of instantiation lemmas tends to increase exponentially over the course of a run of an SMT solver.
The reason is that instantiation lemmas introduce new ground terms, which are in turn used to generate new substitutions that lead to
new instantiation lemmas and so on.
In practice, it is common for E-matching to generate thousands of instantiations after executing only a handful of iterations,
which in turn overload the quantifier-free component of the SMT solver (Lines 2-6 of Figure~\ref{fig:smtq}),
thereby degrading the performance of the system significantly.
It is also important to note that E-matching may diverge on simple examples
as demonstrated in the following example.

\begin{example}
Let $E$ be the set $\{ f( a ) = a \}$ and let $\psi$ be $\forall x\, f( f( x ) ) = f( x )$.
Say we select $f( x )$ as a pattern for $\psi$.
Matching this pattern with $f( a )$ gives us the lemma $\psi \Rightarrow f( f( a ) ) = f( a )$.
Adding the right hand side to $E$, we have that $f( x )$ matches $f( f( a ) )$, giving us the lemma $\psi \Rightarrow f( f( f( a ) ) ) = f( f( a ) )$.
In absence of further heuristics, lemmas of this form will be added indefinitely.
\qed
\end{example}

The aforementioned case is often referred to as a \emph{matching loop}.
Matching loops may be avoided by
restricting pattern selection, or by
considering instantiations in a breadth-first manner by tracking a ``level" on the terms introduced by instantiations~\cite{GeBarrettTinelli07}.

\subsection{Challenge: Incompleteness}

In addition to being non-terminating, if E-matching terminates without return any instantiation lemmas,
this does not imply that $E \cup Q$ is satisfiable, as demonstrated in the following simple example.

\begin{example}
Let $E$ be $\emptyset$ and let $Q = \{ \forall x\, P( x ), \forall x\, \neg P( x ) \}$.
Any pattern selection for the quantified formulas in $Q$ will fail to produce any instantiation lemmas,
since there are no ground terms in $E$.
However, $Q$ clearly is $T$-unsatisfiable.
\qed
\end{example}

Thus, when E-matching saturates with no instances, some SMT solvers will terminate with ``unknown"
or revert to more aggressive techniques for finding instantiations.
Some variants of E-matching ensure completeness by a particular pattern selection specialized to the quantified formulas in question~\cite{dross2016adding,bansaldeciding}.
However, these approaches require an external pencil-and-paper proof by the user and are not fully automated.

\begin{comment}
In spite of its shortcomings, E-matching is highly successful technique 
and is widely used in a number of current applications.
In the following two sections, we will see two techniques that address the aforementioned challenges, in particular:
\begin{itemize}
\item To address the large number of instances produced by E-matching, we will find \emph{conflicts} to prune the search space.
\item To address cases where E-matching adds no instances or we believe the input to be satisfiable, 
we will build candidate \emph{models}. 
\end{itemize}
\end{comment}

\section{Conflict-Based Instantiation}
\label{sec:cbqi}

As mentioned, E-matching often generates an overabundance of instantiation lemmas, 
many of which are irrelevant to the satisfiability of our input,
and which degrade the performance of the SMT solver.
To address this shortcoming, we may use a technique which we refer to as \emph{conflict-based quantifier instantiation}.
This technique was introduced in the context of a modern SMT solvers in~\cite{ReynoldsTinelliMoura14}, 
and has been implemented in solvers such as \cvc and veriT~\cite{DBLP:conf/cade/Barbosa16}.
%The basic idea is to identify instantiation lemmas that are in \emph{conflict} with the current context, 
%and consider such lemmas with higher priority than the others.

Given a quantified formula $\forall \vec x\, \varphi[ \vec x ]$ in $Q$,
we say that $\varphi[ \vec t ]$ is a \emph{conflicting instance} for $( E, Q )$ if $E, \varphi[ \vec t ] \models_T \bot$.
A single conflicting instance exists for $(E, Q )$ suffices to show that $E \cup Q$ is unsatisfiable,
and hence we may return \emph{only} that instance.

\begin{example}
Let $E$ be the set $\{ P(a), \neg P(d), \neg P( c ), \neg R(b), \neg R(a), \neg R(d) \}$ where $a,b,c,d$ are free constants and $P,R$ are unary predicates.
Let $\psi$ be $\forall x\, P( x ) \vee R( x )$.
Recall that E-matching would return instances corresponding to substituting terms $a,b,c,d$ for $x$
assuming $P( x )$ and $R( x )$ are chosen as patterns.
However, consider the result of what we learn from these instantiations relative to information we already know from $E$:
\[
\begin{array}{rcl@{\hspace{1em}}rcl}
E, P( a ) \vee R( a ) &\models& \top &
E, P( b ) \vee R( b ) &\models& P( b ) \\
E, P( c ) \vee R( c ) &\models& R( c ) &
E, P( d ) \vee R( d ) &\models& \bot \\
\end{array}
\]
In other words, since $P( a ) \in E$, we learn no new information from the first instance,
whereas since $\neg P( d ), \neg R( d ) \in E$, we learn $\bot$ from the fourth instance.
In this example, $P( d ) \vee R( d )$ is a conflicting instance for $( E, \{ \psi \} )$.
Conflict-based instantiation would return \emph{only} this lemma and discard the others.
\qed
\end{example}
\begin{example}
We may find instantiations that are conflicting while taking into account equality and uninterpreted functions.
Let $E$ be $\{ a \neq c, f( b ) = b, g( b ) = a, f( a ) = a, h( f( a ) ) = d, h( b ) =c \}$ and let $\psi$ be
$\forall x\, f( g( x ) ) = h( f( x ) )$. 
The instance $f( g( b ) ) = h( f( b ) )$ is a conflicting instance for $( E, \{ \psi \} )$,
by noting
$E \models_\euf f( g( b ) ) = a \wedge h( f( b ) ) = c \wedge a \neq c$
and hence $E, f( g( b ) ) = h( f( b ) ) \models_\euf \bot$.
\qed
\end{example}
It is also helpful to distinguish other instances that are relevant to the satisfiability of $E \cup Q$,
by noting which ones entail equalities between ground terms in $E$.
This behavior is analogous to that of quantifier-free theory solvers, which often use
theory propagation techniques for inferring equalities that prune search space.
\begin{example}
Consider the sets $E$ and $\psi$ from the previous example, but where $a \neq c$ does not occur in $E$.
In this case, $f( g( b ) ) = h( f( b ) )$ is no longer a conflicting instance for $( E, \{ \psi \} )$.
However, notice that we still have that $E, f( g( b ) ) = h( f( b ) ) \models_\euf a = c$.
In the context of Figure~\ref{fig:smtq}, 
adding this instance allows the quantifier-free solver to propagate the equality $a = c$.
In this case, we say that $f( g( b ) ) = h( f( b ) )$ is a \emph{propagating instance} for $( E, \{ \psi \} )$.
\qed
\end{example}
To summarize, the goal of conflict-based instantiation is to {\bf from $Q$, 
learn conflicts and equalities between ground terms in $E$}.
We run conflict-based instantiation prior to running E-matching.
A revised strategy for quantifier instantiation is the following:
\begin{enumerate}
\item If there exists a conflicting instance $\varphi[ \vec t ]$ for $( E, Q )$, 
return $\{ \forall \vec x\, \varphi[ \vec x ] \Rightarrow \varphi[ \vec t ] \}$ only,
\item Otherwise, if there exists a non-empty set of propagating instances $\{ \varphi_1[ \vec t_1 ], \ldots \varphi_n[ \vec t_n ] \}$ for $( E, Q )$,
return $\{ \forall \vec x_1\, \varphi_1[ \vec x_1 ] \Rightarrow \varphi_1[ \vec t_1 ], \ldots, \forall \vec x_n\, \varphi_n[ \vec x_n ] \Rightarrow \varphi_n[ \vec t_n ] \}$ only.
\item Otherwise, return the instantiation lemmas returned by E-matching.
\end{enumerate}
It is important to note that the level of effort put towards 
finding conflicting and propagating instances is flexible.
An implementation that spends more time searching for conflicting instances will potentially add fewer instantiation lemmas,
but will spend more time per lemma added.

\subsection{Impact}

\begin{figure}[t]
\centering
\resizebox{\columnwidth}{!}{$
%\scriptsize
\begin{tabular}{|r|r|c|cc|cc|cc|cc|}
\hline
  &  & & & & \multicolumn{2}{c|}{E-matching}  & \multicolumn{2}{c|}{Conflicting}  & \multicolumn{2}{c|}{Propagating}
\\
&   & \# Solved & IR & \# Inst & \%IR & \# Inst & \%IR & \# Inst & \%IR & \# Inst
\\
\hline 
 TPTP &  {\bf cvc4} & 6100 & 71.6K & 879.0M & 100.0 & 879.0M &  &  &  & 
\\
 & {\bf cvc4+ci} & 6616 & 209.0K & 150.9M & 20.3 & 150.4M & 76.4 & 159.7K & 3.3 & 415.8K
\\
\hline
 Isabelle & {\bf cvc4} & 3858 & 7.0K & 119.0M & 100.0 & 119.0M &  &  &  & 
\\
 & {\bf cvc4+ci} & 4082 & 21.8K & 28.3M & 22.4 & 28.2M & 64.0 & 13.9K & 13.6 & 130.9K
 \\
\hline
 SMT-LIB & {\bf cvc4} & 3680 & 14.0K & 60.7M & 100.0 & 60.7M &  &  &  & 
\\
 & {\bf cvc4+ci} & 3747 & 58.0K & 32.4M & 20.0 & 32.3M & 71.6 & 41.5K & 8.4 & 51.5K
\\
\hline
\end{tabular}
$}
\caption{
Details on unsatisfiable benchmarks solved, and instances constructed by \cvc with and without conflict-based instantiation.
}
\label{fig:results-inst-detail}
\end{figure}

\begin{figure}[t]
\centering{%
\includegraphics[scale=.22, angle=270]{scatter-cbqi.pdf} 
}
\caption{ Number of instantiations reported by
{\bf cvc4+ci} vs {\bf cvc4} over all unsatisfiable benchmarks.
Data shown on a log-log scale.
}
\label{fig:cbqi-scatter}
\end{figure}

Figure~\ref{fig:results-inst-detail}
gives a detailed summary of the impact of conflict-based instantiation in the SMT solver \cvc
on the SMT-LIB, TPTP, and Isabelle benchmark libraries (further details are given in~\cite{ReynoldsTinelliMoura14}).
The data shows \cvc with and without conflict-based instantiation, indicated by {\bf cvc4+ci} and {\bf cvc4} respectively.
Column 3 shows that \cvc with conflict-based instantiation
solves a total of 807 more benchmarks total over the three benchmark sets.
Moreover, it uses significantly fewer instantiations overall to solve these benchmarks.
Column 4 gives the aggregate number of instantiation rounds (IR) taken by these configurations
(in terms of Figure~\ref{fig:smtq}, the number of instantiation rounds is equal to the number of calls to $\funcqi$).
While {\bf cvc4+ci} considers many more instantiation rounds, it adds a total
of 847.1 million fewer instantiations than {\bf cvc4} over the three benchmark sets, as shown in column 5.
In other words, conflict-based instantiation allows \cvc to solve 807 more benchmarks while adding a total of 847.1 million 
less instantiations overall.

Columns 6-11 give the percentage of instantiation rounds taken by the solver 
for which it returns instantiations based on E-matching, a conflicting instance,
or propagating instance(s).
It is interesting to note that conflicting instances are found by {\bf cvc4+ci} on
74.5\% of instantiation rounds, a percentage that is relatively consistent across all three benchmark sets.
When conflicting instances are not found, propagating instances are found on an additional 5.1\% of instantiation rounds.
A vast majority of the instantiations added by {\bf cvc4+ci} are added as a result of E-matching ($>$99\%).

Figure~\ref{fig:cbqi-scatter} gives a scatter plot of the number of instantiations per individual benchmark
across all three sets, where the data is shown on a log scale.
With the exception of only a few outliers, {\bf cvc4+ci} considers fewer instantiations,
and in many cases only requires a handful of instantiations to solve benchmarks for which {\bf cvc4}
requires thousands of instantiations.
Results from~\cite{ReynoldsTinelliMoura14} showed that 2520 benchmarks can be solved by {\bf cvc4+ci}
without resorting to E-matching at all.
Moreover, 94 of these 2520 benchmarks could not be solved by {\bf cvc4} within the timeout,
showing a number of difficult benchmarks can be solved by conflict-based instantiation alone.

\subsection{Challenge: Finding Conflicting Instances}
A key challenge behind conflict-based instantiation
is efficiently identifying which instantiations are conflicting.
A naive approach would be to construct the set of instantiations that E-matching would return, 
and then check if each one of these instances was conflicting.
This is highly inefficient, and partially negates our original motivation.
%and in fact partially negates our original motivation for avoiding this construction.
Instead, implementation of conflict-based instantiation in \cvc uses a stronger version of matching
that takes into account the structure of the bodies of quantified formulas.
As a simple example, for the formula $\forall x\, P( x ) \vee R( x )$, we would match
$P( x )$ against ground terms from $E$ that are currently entailed to be equal to $\bot$, but not $\top$.
Another challenge is finding conflicts in the presence of interpreted symbols.
\begin{example}
\label{ex:conflict-uflia}
Let $E$ be the set $\{ f( 1 ) = 5 \}$ and let $\psi$ be $\forall xy\, f( x + y ) > x + 2 \cdot y$.
The instance $f( -3 + 4 ) > -3 + 2 \cdot 4$ is conflicting for $( E, \{ \psi \} )$,
noting that $E, f( -3 + 4 ) > -3 + 2 \cdot 4 \models_{\uflia} \bot$, where $\uflia$ is the combined
theory of uninterpreted functions and linear integer arithmetic.
\qed
\end{example}
In general, finding conflicting instances can be expensive, 
both because checking entailment modulo theories may be time consuming,
and because finding conflicting instances in the presence of background theories is often not obvious (as demonstrated in Example~\ref{ex:conflict-uflia}).
For these reasons,
the implementation of conflict-based instantiation in \cvc
considers entailment only modulo equality and uninterpreted functions,
and avoids exponential behavior at the cost of being more incomplete for finding conflicting instances. 

\section{Model-Based Instantiation}
\label{sec:mbqi}

We have seen that E-matching is an incomplete procedure,
that is, when it terminates with no instantiation lemmas, this does not imply that our input is satisfiable.
\emph{Model-based instantiation} is technique that addresses this shortcoming,
which was introduced in the context of modern SMT solving in~\cite{GeDeM-CAV-09},
and has since been implemented in several systems~\cite{Jacobs09,ReyEtAl-CADE-13}.

With model-based quantifier instantiation, the basic idea is
to construct a \emph{candidate model} $\I$ that satisfies $E$, 
and then check whether $\I$ satisfies $Q$ as well.
In other words, $\I$ contains a complete interpretation for all free constants and uninterpreted functions occurring in $E$ and $Q$.
Constructing an interpretation that satisfies the quantifier-free constraints in $E$
is typically guaranteed since decision procedures for quantifier-free inputs in SMT tend to produce models.
To check whether an interpretation $\I$ satisfies a quantified formula $\forall \vec x\, \varphi[ \vec x ]$ where $\varphi$ is quantifier-free,
it suffices to show that the quantifier-free formula $\neg \varphi^\I[ \vec k ]$ is \emph{unsatisfiable},
where $\varphi^\I$ is the result of replacing each uninterpreted function in $\varphi$
by its interpretation in $\I$.
If $\neg \varphi^\I[ \vec k ]$ is \emph{satisfiable}, we return an instantiation lemma based on the interpretation of $k$ in a model
for this formula.

\begin{example}
Let $E$ be $\{ \neg P( a ), P( b ), \neg R( b ), \neg R( c ) \}$ and let $\psi$ be $\forall x\, P( x ) \vee R( x )$.
We may construct an interpretation $\I$ that satisfies $E$:
\[
\begin{array}{rcccccccccc}
P^\I & = & \lambda x. & \ite( & x=a, & \bot, & \ite( & x=b, & \top, & \top  & )) \\
R^\I & = & \lambda x. & \ite( & x=b, & \bot, & \ite( & x=c, & \bot, & \bot  & )) \\
\end{array}
\]
Notice that $P^\I$ was constructed as an if-then-else term that has entries corresponding to $P( a ) \Leftrightarrow \bot$
and $P( b ) \Leftrightarrow \top$. Its \emph{default} value (the rightmost occurrence of $\top$ in $P^\I$) was chosen arbitrarily.
Similarly, we fix the existing entries and chose a default value of $\bot$ for $R$.
To check whether $\I$ satisfies $\psi$, we check the satisfiability of:
\[
\neg ( \forall x\, P^\I( x ) \vee R^\I( x ) ) \transform \neg ( P^\I( k ) \vee R^\I( k ) ) \transform \neg ( ite( k=a, \bot, \top) \vee \bot ) \transform ( k = a )
\]
where $k$ is fresh constant.
In other words, after simplification, we find that $\psi$ is not satisfied by $\I$ for all values of $k$ such that $k = a$.
Model-based quantifier instantiation would subsequently return the instantiation lemma $\psi \Rightarrow P( a ) \vee R( a )$.
Notice that this instantiation lemma is not satisfied by $\I$.
Hence, the solver will be forced to choose a new candidate model 
if model-based quantifier instantiation is invoked again.
\qed
\end{example}
\begin{example}
In the previous example, if we had chosen $\top$ as a default value for $R^\I$, our check would have:
\[
\neg ( P^\I( k ) \vee R^\I( k ) ) \transform \neg ( ite( k=a, \bot, \top) \vee ite( k=b, \bot, ite( k=c, \bot, \top)) ) \transform \bot
\]
This formula is unsatisfiable, thus, we cannot find a value of $k$ for which the negation of $\forall x\, P( x ) \vee R( x )$ holds in $\I$.
In other words, $\I$ satisfies $\forall x\, P( x ) \vee R( x )$.
\qed
\end{example}
Intuitively,
model-based quantifier instantiation adds lemmas that refine candidate models
until they are also a model of $Q$, or otherwise the SMT solver finds a conflict.


\subsection{Impact}
Model-based instantiation often enables SMT solvers to
establish the satisfiability of inputs where exhaustive instantiation is infeasible.
In~\cite{ReyEtAl-CADE-13}, an implementation of model-based quantifier instantiation is used
in conjunction with finite model finding techniques in \cvc.
Figure~\ref{fig:inst-mbqi} shows the impact of these techniques for the 1202
benchmarks from the TPTP library.
In both plots, the solid line plots the total number of possible instances of all quantified formulas
in the (smallest) finite model found by \cvc.
For instance, the quantified formula $\forall xyz\, P( x, y, z )$ has $2^3 = 8$ possible instantiations
in a model that interprets the domain of $x,y,z$ each as a set of size $2$.

\begin{figure}[t]
\centering
\subfigure[Number of instantiations without MBQI.]{%
\label{fig:results-tscatter}
\includegraphics[scale=.22, angle=270]{model-size-nmbqi.pdf} 
}
\quad
\subfigure[Number of instantiations with MBQI.]{%
\label{fig:results-iscatter}
\includegraphics[scale=.22, angle=270]{model-size-mbqi.pdf} 
}%
\caption{
Number of instantiations added by \cvc with and without model-based quantifier instantiation
on satisfiable TPTP benchmarks with a 30 second timeout.
}
\label{fig:inst-mbqi}
\end{figure}

The left plot of Figure~\ref{fig:inst-mbqi} shows the number of instances
added by a strategy {\bf cvc4+f} that exhaustively instantiates all quantified formulas,
where this number coincides with the number of possible instantiations for benchmarks for which
{\bf cvc4+f} terminates with a model.
This plot shows that {\bf cvc4+f} scales up to benchmarks having only around 100k instances;
the maximum number of instances considered by {\bf cvc4+f} on a benchmark it solved was 323k.
In contrast, the right plot of Figure~\ref{fig:inst-mbqi} shows the number of instances
added with model-based quantifier instantiation ({\bf cvc4+fm}).
This strategy solves a superset of the benchmarks solved by {\bf cvc4+f},
solving some benchmarks having more than 1 billion possible instantiations,
and often adding far fewer than the number of possible instantiations before terminating with a model
as demonstrated by the points in the plot occurring below the solid line.

\subsection{Completeness}
We have now seen that SMT solvers may answer ``unsat" using quantifier instantiation
when they discover a finite set of instances that are collectively unsatisfiable at the quantifier free,
and may answer ``sat" if they discover a candidate model that satisfies all quantified formulas.
It is worth noting when these solvers are guaranteed to terminate.

Approaches that incorporate model-based instantiation are clearly terminating
when the domains of quantified formulas have a fixed finite interpretation
such in quantified Boolean formulas (QBF)~\cite{janota2012solving},
or quantified bit-vectors~\cite{wintersteiger2013efficiently}.
For quantified formulas over unintepreted sorts,
finite model finding approaches~\cite{ReyEtAl-1-RR-13} are generally finite-model complete,
that is guaranteed to terminate with ``sat" when there exists a model that interprets
all uninterpreted sorts as finite sets, and are complete for fragments
that exhibit a small model property.
More generally, approaches for model-based quantifier instantiation are terminating in cases
where it can be argued that only a finite number of instantiation lemmas will be returned before 
a model is found~\cite{ihlemann2008local,GeDeM-CAV-09}.
The work of~\cite{GeDeM-CAV-09} examines a class of formulas known as the essentially uninterpreted fragment,
where it can be argued that if a computation of the relevant domain of quantified formulas is finite,
then an instantiation strategy can be made that is complete.
This fragment includes some quantified formulas over infinite domains such as the integers.
%Other fragments that extend Bernays-Schonfinkel have been studied in recent work~\cite{}.

\subsection{Challenge: Constructing Models}
The core challenge to model-based quantifier instantiation is how to construct candidate models $\I$.
As mentioned, common approaches to model-based quantifier instantiation
construct almost constant interpretations for all uninterpreted functions.
This limits their strength both in terms of performance in practice and completeness.

\begin{example}
Let $\psi$ be $\forall xy\, f( x, y ) \geq x \wedge f( x, y ) \geq y$, where $x$ and $y$ are integers.
This formula has a model where $f$ is interpreted as $\lambda xy\, \ite( x \geq y, x, y )$,
but does not have a model where $f$ is almost constant.
\qed
\end{example}

\begin{example}
Let $\psi$ be $\forall x\, 3 \cdot g( x ) + 5 \cdot h( x ) = 0$.
This formula has a model where $g$ and $h$ are interpreted as $\lambda x\, 5 \cdot x$ and $\lambda x\, \text{-}3 \cdot x$ respectively,
but does not have a model where they are almost constant.
\qed
\end{example}

%Generally speaking, 
%the shape of the quantified formulas determines the shape of the models

\section{Specialized Instantiation for Theories}
\label{sec:cegqi}

We have seen three classes of general-purpose techniques 
for instantiation for quantified formulas in SMT.
The common thread thus far has been that determining the satisfiability of universally quantified formulas in presence
of uninterpreted functions and theory symbols is challenging, and in fact is undecidable in general.
However, when no uninterpreted function symbols are present and the background theory admits quantifier elimination, 
e.g. linear real and integer arithmetic, then satisfiability 
can be established by a quantifier elimination procedure~\cite{cooper1972,FerranteRackoff79ComputationalComplexityLogicalTheories,Loos93applyinglinear}.
Recent work has adapted quantifier elimination techniques in the context of SMT solving~\cite{monniaux2010quantifier,ReynoldsDKBT15Cav,DBLP:conf/lpar/BjornerJ15},
and has been implemented in SMT solvers
as well as tools that use SMT solvers as a backend~\cite{komuravelli2014smt,DBLP:conf/lpar/FedyukovichGS15}.

Let $\exists \vec x\, \varphi[ \vec x, \vec k ]$ be a quantified formula in a background theory $T$.
Assuming $T$ admits quantifier elimination, we know that this formula is equivalent to some finite disjunction
$\varphi[ \vec t_1, \vec k ] \vee \ldots \vee \varphi[ \vec t_n, \vec k ]$ where $\vec{t_1}, \ldots, \vec{t_n}$ are tuples of terms, possibly containing free constants from $\vec k$.
We may alternatively consider a lazy quantifier \emph{instantiation} procedure for establishing the satisfiability 
$\forall \vec x\, \neg \varphi[ \vec x, \vec k ]$ that considers only instantiations of the form 
$\neg \varphi[ \vec t_i, \vec k ]$ where $\vec t_i$ is one of $t_1, \ldots, t_n$.
Assuming instantiations of this form are considered by the procedure only, it is terminating.
Moreover, the procedure may terminate early if at any point it finds a set
$\{ \neg \varphi[ \vec t_{i1}, \vec k ], \ldots, \neg \varphi[ \vec t_{im}, \vec k ] \}$ that is either
$T$-unsatisfiable, or is $T$-satisfiable and entails $\forall \vec x\, \neg \varphi[ \vec x, \vec k ]$,
where ideally $m$ is much smaller than $n$.

An approach for selecting instantiation lemmas based on models for the negation of quantified formulas
over linear arithmetic is given in~\cite{InstLA2016}, where the basic idea is the following.
Let $\psi$ be a quantified formula of the form $\forall x\, \varphi[ x ]$ where $\varphi$ is a quantifier-free formula over linear real arithmetic.
First, find a model for $E \cup \neg \varphi[ k ]$ where $E$ is the current set of quantifier-free constraints known by the solver and $k$ is fresh real variable.
If none exists, then $\psi$ is satisfied by all models of $E$.
Otherwise, let $\{ k \geq t_1, \ldots, k \geq t_n \}$ be (equivalent to) atoms from $E \cup \neg \varphi[ k ]$ that are satisfied by $\I$,
find the bound $k \geq t_i$ such that $t_i^\I \geq t_j^\I$ for all $j \neq i$,
and return the instantiation lemma $\psi \Rightarrow \varphi[ t_i ]$.
In other words, select an instantiations based on the current maximal lower bound for $k$ (alternatively, instantiations may be selected based on the current minimal upper bound).

\begin{example}
\label{ex:cegqi}
Let $E$ be the set $\{ a=b+5 \}$ and let $\psi$ be $\forall x\, (x>a \vee x<b \vee x-c<3)$.
Consider the set $E' = E \cup \{ k \leq a, k \geq b, k \geq c+3 \}$ where $k$ is a fresh variable.
This set is satisfiable with a model $\I$ that interprets $a^\I = 5, b^\I = 0, c^\I = 0, k^\I = 3$.
Consider the lower bounds for $k$ in set $E'$, and their interpretation in $\I$:
\[
\begin{array}{ccccc}
k & \geq & b^\I & = & 0 \\
k & \geq & (c+3)^\I & = & 3 \\
\end{array}
\]
We find the term $c+3$ is the maximal lower bound for $k$ in $\I$,
and return the instantiation lemma $\psi \Rightarrow ( c+3>a \vee c+3<b \vee (c+3)-c<3 )$.
Note that any model $\J$ satisfying $E'$ and this instantiation lemma is such that $b^\J > (c+3)^\J$,
and hence $c+3$ will not be the maximal lower bound for $k$ for such a $\J$.
\qed
\end{example}

In practice,
The aforementioned approach for instantiation for linear arithmetic often terminates well before considering the worst-case number of instantiations~\cite{DBLP:conf/lpar/BjornerJ15,InstLA2016}.
Here, we have shown one option for selecting instantiations based on maximal lower or minimal upper bounds,
which intuitively can be understood as a lazily enumerating the disjuncts in Loos and Weispfenning's method for quantifier elimination~\cite{Loos93applyinglinear}.
Although not shown here, the instantiations returned by this approach may involve \emph{virtual terms} such as infinitesimals for dealing with cases where bounds on $k$ are strict,
and infinities for dealing with cases where $k$ is unbounded.
Another alternative for linear arithmetic is to instantiate with the midpoint of the
maximal lower and minimal upper bounds,
which can be understood as enumerating disjuncts in Ferrante and Rackoff's method for quantifier elimination~\cite{FerranteRackoff79ComputationalComplexityLogicalTheories}.
An instantiation strategy for linear integer arithmetic can be devised that adds constants to lower bounds to take into account divisibility constraints (for details, see~\cite{InstLA2016}),
which simulates Cooper's method~\cite{cooper1972}.
For other background theories such as fixed-width bit-vectors, 
a naive approach can be devised that instantiates the original quantified formula based on the \emph{value} $k^\I$.
In all of the aforementioned cases, we may argue that the set of possible instantiation lemmas returned by this strategy is finite.
Hence, a terminating procedure for the satisfiability of quantified formulas in these theories based on lazy quantifier instantiation can be devised.

%Conversely, the aforementioned instantiation strategy fails to be effective when uninterpreted functions are present.

\section{Conclusion}
\label{sec:conclusion}

We have seen strategies for quantifier instantiation
based on heuristics, conflicts, and models.
%These are summarized in Figure~\ref{fig:smtqi},
For quantified formula with uninterpreted functions,
a strategy for quantifier instantiation may give highest priority to instantiations that
are conflicting with the current satisfying assignment,
subsequently give priority to instantiations returned by heuristics such as E-matching,
and finally consider instances that refine candidate models.
Quantified formulas in pure background theories such as linear arithmetic can be 
decided by particular strategies for selecting instantiation lemmas, for instance
based on candidate models and the current set of constraints known by the solver.

\begin{comment}
\begin{figure}[t]
\begin{framed}
$\funcqi( E, Q )$: \\
\begin{enumerate}
\item[\ ] Do one of the following:
\begin{itemize}
\item If $E \models_T \neg \varphi[ \vec t ]$ for some $\vec t$, $\forall \vec x\, \varphi[ \vec x ] \in Q$, \hfill ({\bf Conflicts})
\begin{enumerate}
\item[\ ] return $( \text{``unknown"}, \{ \forall \vec x\, \varphi[ \vec x ]  \Rightarrow \varphi[ \vec t ] \} )$.
\end{enumerate}
\item Return $( \text{``unknown"}, L )$ based on e.g. E-matching. \hfill {\bf(Heuristics)}
\item Let $\I$ be a model of $E$. \hfill {\bf(Models)}
\item[\ ] If $\I \models \neg \varphi[ \vec t ]$ for some $\vec t$, $\forall \vec x\, \varphi[ \vec x ] \in Q$,
\begin{enumerate}
\item[\ ] return $( \text{``unknown"}, \{ \forall \vec x\, \varphi[ \vec x ]  \Rightarrow \varphi[ \vec t ] \}$ ).
\end{enumerate}
\item[\ ] Otherwise, return $( \text{``sat"}, \emptyset )$.
\end{itemize}
\end{enumerate}
\end{framed}
\vspace{-2ex}
\caption{Summary of techniques for quantifier instantiation in SMT, as subprocedure of Figure~\ref{fig:smtq}.
\label{fig:smtqi}}
\end{figure}
\end{comment}

There is room to improve upon current implementations of quantifier instantiation in SMT solvers,
both in terms of engineering and theory.
There are many design decisions behind all strategies mentioned in this paper, 
many of which are not mentioned here.
It has yet to be explored how conflict-based instantiation can be implemented eagerly,
and if it can be efficiently applied in the presence of background theories.
There is also potential for incorporating more sophisticated schemes for function models that go beyond almost constant functions
for model-based quantifier instantiation.

As mentioned, quantifier instantiation techniques based on E-matching
are often highly effective and well-behaved for fragments where theory symbols are scarce.
Conversely, recent techniques for quantifier instantiation are highly effective for quantifiers containing purely theory symbols,
as mentioned in Section~\ref{sec:cegqi}.
For tackling problems that depend both on reasoning about theories and uninterpreted functions,
it is yet to fully understood to what extent these techniques can be combined,
and how this combination can be implemented in practice.

Additionally, there are opportunities to extend SMT solvers with efficient dedicated support for
new fragments of first order logic of interest, including pure quantified formulas in additional background theories.
There is potential for improving support for quantified formulas over fixed-width bit-vectors,
where the bit-precise versions of arithmetic operators are part of the signature supported by many SMT solvers.
We expect analogous techniques for selecting instantiations in the spirit of Section~\ref{sec:cegqi} to be helpful here.
It has further yet to be explored how instantiation techniques can be adapted
for other theories such as unbounded character strings, finite sets, and floating points, 
which several SMT solvers now support at the quantifier-free level.

\bibliographystyle{abbrv}
\bibliography{main}


\end{document}






