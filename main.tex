\documentclass[oribibl]{llncs}

%\usepackage{pslatex}

\usepackage{times}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{mathpartir} % ./
\usepackage{color}
\usepackage{xspace} 
\usepackage[pdftex]{graphicx}
%\usepackage[small]{caption}
\usepackage{fancybox}
\usepackage{url}
\usepackage{multirow}
\usepackage{comment}
\usepackage{listing}
\usepackage{colortbl}

%\usepackage{times}
\usepackage{framed}
\usepackage{lineno}

\input{macros}
\renewcommand{\shadowsize}{1pt}

\begin{document}

\title{Conflicts, Models and Heuristics for Quantifier Instantiation in SMT}

\author {Andrew Reynolds\inst{1}}

\institute{
Department of Computer Science, The University of Iowa, USA
}
\maketitle

\pagestyle{plain}
%\pagestyle{empty}

\begin{abstract}
[SMT solvers]
[Quantifier Instantiation]
[Techniques for UF]
[New techniques for theories]
[Summary]
\end{abstract}

\section{Introduction}

[SMT solvers now handle quantifiers]
Satisifiability Modulo Theories (SMT) solvers 

[Important in Applications]

The use of quantified formulas is highly important in a number of applications,
including automated theorem proving~\cite{}, software verification~\cite{}, synthesis~\cite{}, and planning~\cite{}.

[Challenging in Theory]


[Handled well in Practice]
In spite of the theoretical challenges, quantified formulas
can be handled well in practice by modern automated theorem provers and SMT solvers.


A growing number of modern tools exist for reasoning about first-order quantified formulas.
A number of automated theorem provers,
(such as Vampire~\cite{}, E~\cite{}, and SPASS~\cite{}), were originally developed to target 
quantified formulas in single-sorted first-order logic.
More recently, these solvers have been exten
For the most part, theorem provers from this community are superposition-based,
although some are instantiation-based such as the Inst-Gen calculus used by iProver~\cite{}.

Conversely, SMT solvers (such as CVC~\cite{}, Yices~\cite{}, and Z3~\cite{}), 
were originally developed to target quantifier-free formulas in background theories,
but have more recently been extended with support for universally quantified formulas.
The approaches here are mostly instantiation-based based~\cite{},
although some approaches are based on superposition~\cite{}.
SAT and SMT solvers for quantifier-free formulas have also been leveraged in
superposition-based theorem proving in an approach known as AVATAR~\cite{}.

This paper will focus primarily on recent techniques for quantifier instantiation in SMT solvers.
In Section~\ref{sec:quant}, we outline an abstract procedure used by most SMT solvers with support for quantified formulas.
%Sections~\ref{sec:ematching}-~\ref{sec:mbqi} will overview modern general-purpose techniques 
%for quantifier instantiation in SMT.
Section~\ref{sec:ematching} will discuss general-purpose and incomplete methods for handling quantified formulas in SMT.
Section~\ref{sec:cbqi} will examine how finding \emph{conflicts} can improve the ability of the techniques for answering ``unsat",
and Section~\ref{sec:mbqi} will examine how constructing \emph{candidate models} can enable the solver to answer ``sat".
Section~\ref{sec:cegqi} introduces further techniques for quantifier instantiation in SMT that 
are specialized to theories.
Finally, we conclude in Section~\ref{sec:conclusion} with a summary and mention possible future work.

\section{Support for Quantified Formulas in an SMT Solver}
\label{sec:quant}

Most modern SMT solvers are based on the DPLL($T$) solving architecture,
where a set of decision procedures for $T$ are modularly combined with a SAT solver for propositional satisfiability~\cite{}.
Given a set of $T$-formulas $\Gamma$ as input to a DPLL($T$)-based SMT solver, its underlying SAT solver
abstracts each $T$-literal in $\Gamma$ as unique Boolean variable.
The SAT solver clausifies $\Gamma$ and returns that 
either $\Gamma$ is propositionally unsatisfiable (in which case it is also $T$-unsatisfiable),
or returns a set of literals $M$ that propositionally entail it.
We write $M \models_p \Gamma$ to denote this case, and refer to $M$ as a satisfying assignment for $\Gamma$.
It then uses a decision procedure for $T$ to
check the $T$-satisfiability of $M$, that is, whether there exists of model of $M$ that is consistent according to theory $T$.
If $M$ is $T$-satisfiable, then we may conclude that $\Gamma$ is $T$-satisfiable.
Otherwise, it returns a subset $C$ of $M$ that is $T$-unsatisfiable and adds the clause $\neg C$ to $\Gamma$,
which is often referred to as a conflict clause.

%In DPLL($T$), each theory literal and closed universally quantified formula is abstracted as a unique Boolean variable.
%The underlying SAT solver 

DPLL($T$)-based SMT solvers have been extended in the past decade with approaches for univeral and existential quantification~\cite{}.
For consistency, in this paper we assume all existential quantification is rewritten to universal quantification by the rewrite:
\[
\exists \vec x\, P( \vec x ) \transform \neg \forall \vec x\, \neg P( \vec x )
\]
In a DPLL($T$)-based approach for quantified formulas, 
each closed (universally) quantified formula is abstracted as a Boolean variable by the SAT solver as well.

\begin{example}
Consider the set of $\uflia$-formulas:

\end{example}

\begin{figure}[t]
\begin{framed}
\begin{internallinenumbers}
$\funcsmtsolve( \Gamma )$:
\begin{enumerate}
\item[\ ] If $\Gamma$ is propositionally unsatisfiable,
\begin{enumerate}
\item[\ ] return ``unsat".
\end{enumerate}
\item[\ ] Otherwise, let $M = E \uplus Q$ be a set of literals such that $M \models_p \Gamma$.
\item[\ ] If $E$ is $T$-unsatisfiable,
\begin{enumerate}
\item[\ ] return $\funcsmtsolve( \Gamma \cup \neg C )$ for some $T$-unsatisfiable $C \subseteq E$.
\end{enumerate}
\item[\ ] Otherwise, let $( r, L ) = \funcqi( E, Q )$.
\item[\ ] If $r$ is ``unknown",
\begin{enumerate}
\item[\ ] return $\funcsmtsolve( \Gamma \cup L )$.
\end{enumerate}
\item[\ ] Otherwise, return ``sat".
\end{enumerate}
$\funcqi( E, Q )$:
\begin{enumerate}
\item[\ ] Do one of the following:
\begin{enumerate}
\item[\ ] Return $( \text{``sat"}, \emptyset )$, if $E \cup Q$ is $T$-satisfiable.
\item[\ ] Return $( \text{``unknown"}, L )$ for some set $L$ of $T$-lemmas.
\end{enumerate}
\end{enumerate}
\end{internallinenumbers}
\end{framed}
\vspace{-2ex}
\caption{An abstract procedure for $T$-inputs $\Gamma_0$ with quantified formulas in an SMT solver.
In Line 5, $E$ is quantifier-free, and the atoms of each literal in $Q$ are universally quantified formulas.
\label{fig:smtq}}
\end{figure}

Figure~\ref{fig:smtq} gives an abstract procedure $\funcsmtsolve$
for establishing the $T$-satisfiability of a set of $T$-formulas $\Gamma$ possibly containing universal quantification.
Lines 2 through 6 correspond to a DPLL($T$)-based approach for quantifier-free inputs.
In Line 5, we partition $M$ into two parts $E$ and $Q$,
where $E$ is quantifier-free and the atoms of literals in $Q$ are universally quantified formulas.
If the quantifier-free portion is $T$-satisfiable,
we proceed to Line 7, which invokes the procedure $\funcqi$ on $E$ and $Q$.
Abstractly, this procedure either may determine that $E \cup Q$ is $T$-satisfiable and return the pair $( \text{``sat"}, \emptyset )$,
or otherwise will return ( ``unknown", $L$ ), where $L$ is a set of formulas that are valid in theory $T$,
after which the procedure $\funcsmtsolve$ either terminates with ``sat" or adds $L$ to $\Gamma$ and repeats.

Designing support for quantified formulas in DPLL($T$)-based SMT solvers 
primarily depends on how the function $\funcqi$ is implemented.
We will examine such an implementation in this paper, in particular addressing the questions:
\begin{itemize}
\item How can we establish that $E \cup Q$ is $T$-satisfiable (when $Q$ is non-empty)?
\item What lemmas $L$ should we return?
\end{itemize}

It is important to note that some SMT approaches to quantified formulas
reason about quantified formulas \emph{eagerly} during the DPLL($T$) search~\cite{}.
In terms of Figure~\ref{fig:smtq}, these approaches invoke $\funcqi$
for sets $M$ that are incomplete and do not necessarily propositinally entail all formulas in $\Gamma$.
The advantage of doing so is that lemmas returned by $\funcqi$ may help prune the search,
while the disadvantage is that calling $\funcqi$ may be expensive and lead to non-termination.
For simplicity, we assume a lazy approach for handling quantified formulas.

\subsection{Skolemization and Instantiation}
Common implementations of $\funcqi( E, Q )$ in SMT solvers return sets $L$ consisting of $T$-lemmas of the following two forms:
\begin{enumerate}
\item $\neg \forall \vec x\, P( \vec x ) \Rightarrow \neg P( \vec k )$, where $\vec k$ is a set of fresh \emph{Skolem} variables, and
\item $\forall \vec x\, P( \vec x ) \Rightarrow P( \vec t )$, where $\vec t$ is a tuple of ground terms.
\end{enumerate}
Lemmas of the first type, which we refer to as \emph{Skolemization lemmas},
 witness the negation of universally quantified formulas for a fresh set of variables $\vec{k}$,
are returned for each quantified formula whose negation occurs in $Q$.
Notice that such lemmas need only be added once per quantified formula.
Lemmas of the second type, which we refer to as \emph{instantiation lemmas},
infer an instance of a universally quantified formula for some tuple of ground terms $\vec{ t }$.
In contrast, multiple lemmas of this form may be added per quantified formula.
The performance of the solver is highly dependent on a having a good strategy for selecting instantiation lemmas.
We examine various strategies for selecting instantiation lemmas in Sections~\ref{sec:ematching}-~\ref{sec:cegqi}.

\section{E-matching}
\label{sec:ematching}

The most widely used technique for quantifier instantiation in SMT a heuristic technique known as \emph{E-matching}.
It was originally introduced in the Ph.D. thesis of Greg Nelson~\cite{}.
Recently, variants of the approach have been implemented in a number of successful SMT solvers~\cite{}.
The support for E-matching in these solvers is critical to the success of high-level reasoning tools for 
software verfication~\cite{} and automated theorem proving~\cite{}.
E-matching chooses instances for quantified formulas $\forall \vec x\, \varphi$
based on \emph{pattern} terms whose free variables are $\vec x$.
We will write $p[ \vec x ]$ to denote a term whose free variables are $\vec x$.
%Formally, 
%we say that a ground term $g$ matches $p$ modulo $E$ under substitution $\{ \vec x \mapsto \vec t \}$ if $E \models_T g = p \{ \vec x \mapsto \vec t \}$.
In detail, 
E-matching does the following for each $\forall \vec x\, \varphi$ occurring in $Q$:
\begin{enumerate}
\item Choose a set of patterns $p_1[ \vec x ], \ldots, p_m[ \vec x ]$.
\item For each $j = 1, \ldots, m$,
\begin{enumerate}
\item Compute a set of pairs $(\vec t_{1},g_{1}), \ldots, (\vec t_{n}, g_{n})$ 
where for each $i = 1, \ldots, n$, we have that $g_i$ is a ground term from $E$ such that $E \models_T g_{i} = p_j[ \vec t_{i} ]$.
\item Return the lemmas $\{ \forall x\, \varphi[\vec x] \Rightarrow \varphi[\vec t_{1}], \ldots, \forall x\, \varphi[\vec x] \Rightarrow \varphi[\vec t_{n}] \}$.
\end{enumerate}
\end{enumerate}

In other words, we first select some set of pattern terms, which are often some of the subterms of $\varphi$.
For each of these patterns $p_j[ \vec x ]$, we compute a set of pairs of the form $( \vec t_i, g_i )$ where 
$g_i$ is equivalent to $p_j[ \vec t_i ]$ under the assumption that $E$ holds.
We then return instantiation lemmas corresponding to each of these pairs. 
In the context of Figure~\ref{fig:smtq}, these lemmas are included in the return value of $\funcqi$ (set $L$).
Notice in this description, we write $E \models_T g_{i} = p_j[ \vec t_{i} ]$ to denote that $E$ entails
$g_{i} = p_j[ \vec t_{i} ]$ modulo theory $T$.  In typical E-matching implementations, $T$ is limited to the theory of uninterpreted functions and equality.
%We demonstrate this technique in the following examples.

\begin{example}
\label{ex:em2}
Let $E$ be the set $\{ P(a), \neg P(b), R(c), \neg R(a), S(d) \}$ where $a,b,c,d$ are free constants and $P,R,S$ are unary predicates.
Let $\psi$ be $\forall x\, P( x ) \vee R( x )$.
Say we choose the pattern terms $P( x )$ and $R( x )$ for $\psi$.
In Step 2, we compute pairs $( a, P( a ) )$ and $( b, P( b ) )$ for $P( x )$ and
$( a, R( a ) )$ and $( c, R( c ) )$ for $R( x )$.
Thus, E-matching returns $\{
\psi \Rightarrow P( a ) \vee R( a ), \psi \Rightarrow P( b ) \vee R( b ), \psi \Rightarrow P( c ) \vee R( c )
\}$.
\qed
\end{example}

\begin{example}
\label{ex:em2}
E-matching also takes into account matching modulo equality.
For example, let $E$ be the set $\{ P( a, c ), f( b ) = a \}$,
let $\psi$ be $\forall xy\, P( f( x ), y ) \Rightarrow g( x ) = y$,
and let $P( f( x ), y )$ be a pattern for it.
We may consider the pair $( ( b, c ), P( a, c ) )$, which is such that $E \models_\euf P( a, c ) = P( f( b ), c )$ since $f( b ) = a \in E$,
where $\models_\euf$ denotes entailment the theory of equality and uninterpreted functions.
Thus, E-matching in this example returns $\{ \psi \Rightarrow ( P( f( b ), c ) \Rightarrow g( b ) = c \}$.
\qed
\end{example}

Recall in function $\funcqi$, we are interested in the (un)satisfiability of $E \cup Q$.
As mentioned, E-matching selects instantiation lemmas based on pattern matching.
It is typically very effective for establishing unsatisfiability.
The intuition for its effectiveness is the following. 
Let $\psi$ be a formula in $Q$ of the form $\forall \vec x\, \varphi[ p[ \vec x ], \vec x ]$, 
that is, $p[ \vec x ]$ is a subterm of $\psi$,
Assume $p[ \vec x ]$ is selected as a pattern for $\psi$, and
that a ground term $g$ from $E$ is such that $E \models_T g = p[ \vec t ]$.
This furthermore implies that $E, \varphi[ p[ \vec t ], \vec t ] \models_T \varphi[ g, \vec t ]$,
that is, by adding an instance of $\psi$ to $E$ we learn that $\varphi[ g, \vec t ]$ holds as well.
%The effect of learning the instantiation $\varphi[ p[ \vec t ], \vec t ]$ 
%suffices to learn $\varphi[ g, \vec t ]$ under the assumption of $E$,
%that is, $E, \varphi[ p[ \vec t ], \vec t ] \models_T \varphi[ g, \vec t ]$.
In other words, when using E-matching for selecting instances of quantified formulas {\bf from $Q$, 
we learn information about ground terms in $E$}.
% i.e. the formula $\varphi[ g, \vec t ]$.
In Example~\ref{ex:em2}, the instantiation lemma returned by E-matching tells us
that the ground term $P( a, c )$ from $E$ entails $g( b ) = c$, under the assumption that $E$ holds.
%We further comment on this intuition in Section~\ref{sec:cbqi}.

\subsection{Pattern Selection}
There is no standard way to determine which patterns to select in E-matching.
The performance of SMT solvers is highly dependent upon having a good pattern selection, as noted in recent work~\cite{}.
In practice, patterns for quantified formulas can be can either be selected manually by the user~\cite{},
or selected automatically by the SMT solver.

For the latter, SMT solvers typically select patterns for $\forall \vec x\, \varphi$ that are subterms $\varphi$,
and are applications of uninterpreted functions.
For example, if $\varphi$ is $f( x, y ) = x + y$ where $f$ is uninterpreted, then $f( x, y )$ would be selected as a pattern
but not $x + y$.
Moreover, they tend to select multiple eligible patterns when multiple are available, 
e.g. $P( x )$ and $R( x )$ may be selected for $P( x ) \vee R( x )$.
Another key choice in pattern selection is whether to consider nested terms, e.g. when $\varphi$ is $P( f( x ) )$,
we may either select $f( x )$ or $P( f( x ) )$, where the latter selection leads to strictly fewer instantiations.
If no eligible term contains all the free variables in $\vec x$, then it selects a pattern consisting of multiple terms.
These are often called \emph{multi-patterns}.
For example, for $R( x, y ) \wedge R( y, z ) \Rightarrow R( x, z )$, then the set $\{ R( x, y ), R( y, z ) \}$ is a multi-pattern.
E-matching would add an instance for this multi-pattern if it could find a substitution for $x, y, z$
that simulatenously matched both of these terms to ground terms in the current context.
Multi-patterns tend to lead to many instantiations, and hence they tend to be chosen with lower priority.
It is yet to be explored how recent techniques for literal selection in automated theorem provers~\cite{}
relate to pattern selection in SMT solvers.

\subsection{Challenge: Too Many Instances}

\begin{figure}[t]
\centering
{
\begin{tabular}{|c|cc|cc|cc|}      
\hline                                                                      
\#Instances & \multicolumn{2}{c|}{{\bf cvc3}} & \multicolumn{2}{c|}{{\bf cvc4}} & \multicolumn{2}{c|}{{\bf z3}} \\
\hline   
1-10 & 1464 & 13.5\% & 1007 & 8.9\% & 1321 & 11.4\% \\
10-100 & 1755 & 16.2\% & 1853 & 16.3\% & 2554 & 22.1\% \\
100-1000 & 3816 & 35.2\% & 3680 & 32.4\% & 4553 & 39.4\% \\
1000-10k & 1893 & 17.4\% & 2468 & 21.7\% & 1779 & 15.4\% \\
10k-100k & 1162 & 10.7\% & 1414 & 12.5\% & 823 & 7.1\% \\
100k-1M & 560 & 5.2\% & 607 & 5.3\% & 376 & 3.3\% \\
1M-10M & 193 & 1.8\% & 330 & 2.9\% & 139 & 1.2\% \\
$>$10M & 10 & 0.1\% & 0 & 0.0\% & 8 & 0.1\%  \\                           
\hline                                                                
\end{tabular}
\\
}
\caption{Number of instantiations by implementations of E-matching in SMT solvers
on benchmarks they solve from the SMT-LIB, TPTP and Isabelle, with a 300 second timeout. Data taken from~\cite{}.}
\label{fig:results-inst}
\end{figure}

One of the central challenges when using E-matching is dealing with the large number of instantiations it generates.
Figure~\ref{fig:results-inst} gives statistics on the number of instantiations returned by three implementations of E-matching 
on benchmarks they solve from the the SMT-LIB library~\cite{}, the TPTP library~\cite{}, and Isabelle~\cite{}.
For example, cvc4 solves 1853 benchmarks for which it added between 10 and 100 instantiation lemmas.
We can see from this data that the median number of instantiations tends to be between 100 and 1000,
and a majority of benchmarks taking between 10 and 10 thousand instantiations.
When isolated to benchmarks for which at least one solver times out, 
the median
A number of benchmarks are solved after upwards of one million instantiations,
and z3 solves one benchmark in the TPTP library after adding more than 19.5 million instantiations.

Instantiation lemmas introduce new ground terms, which are in turn used to generate new substitutions and so on.
It is common for E-matching to generate thousands of instantiations after executing only a handful of iterations.
These instantiations can often overload the quantifier-free component of the SMT solver (Lines 2-6 of Figure~\ref{fig:smtq}),
thereby degrading the performance of the system significantly.

It is also important to note that E-matching may diverge on simple examples
as demonstrated in the following example.

\begin{example}

\end{example}

The aforementioned case is often referred to as a \emph{matching loop}.
Matching loops may be avoided by
restricting pattern selection, or by
considering instantiations in a bredth-first manner (by tracking a ``level" on the terms introduced by instantiations)~\cite{}.

\subsection{Challenge: Incompleteness}

If E-matching fails to return any instantiation lemmas,
this does not imply that $E \cup Q$ is satisfiable, as demonstrated in the following simple example.

\begin{example}
Let $E$ be $\emptyset$ and let $Q = \{ \forall x\, P( x ), \forall x\, \neg P( x ) \}$.
Any pattern selection for the quantified formuls in $Q$ will fail to produce any instantiation lemmas,
since there are no ground terms in $E$.
However, $Q$ clearly is $T$-unsatisfiable.
\qed
\end{example}

Thus, when E-matching saturates with no instances, some SMT solvers will terminate with ``unknown"
or revert to more aggressive techniques for finding instantiations.
Some variants of E-matching ensure completeness by a particular pattern selection specialized the quantified formulas in question~\cite{}.
However, these approaches require an external pencil-and-paper proof by the user and not fully automated.

\ 

In spite of its shortcomings, E-matching is highly successful technique 
and is widely used in a number of current applications.
In the following two sections, we will see two techniques that address the aforementioned challenges, in particular:
\begin{itemize}
\item To address the large number of instances produced by E-matching, we will find \emph{conflicts} to prune the search space.
\item To address cases where E-matching adds no instances or we believe the input to be satisfiable, 
we will build candidate \emph{models}. 
\end{itemize}


\section{Conflict-Based Instantiation}
\label{sec:cbqi}



[Introduction]


[Example]

[Extension to EUF]

[Intuition]

\subsection{Impact}

\subsection{Challenge: Finding Conflicting Instances}

\section{Model-Based Instantiation}
\label{sec:mbqi}

[Introduction]

[Example]

\subsection{Impact}

\subsection{Completeness}

[Fixed-finite, finite, finite instantiation]

\subsection{Challenge: Constructing Models}

[Example]

\section{Counterexample-Guided Instantiation}
\label{sec:cegqi}

[Restate challenges]

[Quantifier Elimination]

[Basic idea]

[Example]

[Results]

\section{Conclusion}
\label{sec:conclusion}

\subsection{Summary}
[for UF]

[for no UF]

\subsection{Future Work}

[Engineering existing]

[Counterexample-guided for theories]

[Combining E-matching + counterexample-guided]

\bibliographystyle{abbrv}
\bibliography{main}


\end{document}






